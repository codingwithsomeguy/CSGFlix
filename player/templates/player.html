<html>
<head>
<title>player</title>
</head>
<body>
Video Player:<br>
<img id="videoimg" width="426" height="240" style="background-color:black">

<br><br>
<table><tbody>
<tr>
<td>Actual Size:</td>
<td>Delta Canvas:</td>
</tr>
<tr height="250" width="860" valign="top">
<td width="430">
<canvas id="canvas" width="426" height="240" style="background-color:black">
</canvas>
</td>
<td width="430">
<canvas id="deltacanvas" width="426" height="240" style="background-color:black">
</canvas>
</td>
</tr>
</tbody></table>



<script>
const w = 426;  const h = 240;

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const offcanvas = new OffscreenCanvas(w, h);
const offCtx = offcanvas.getContext("2d");

ctx.clearRect(0, 0, w, h);
offCtx.clearRect(0, 0, w, h);


function showImageArray(useThisContext, imgArray) {
    const iData = offCtx.createImageData(
        useThisContext.canvas.width, useThisContext.canvas.height);
    for (let i = 0, j = 0; j < imgArray.length; ++i) {
        if ((i % 4) == 3) { // A
            iData.data[i] = 255;
        } else {    // R G B
            // disable RGB777 --> RGB888 for now
            //iData.data[i] = (imgArray[j]<<1);
            iData.data[i] = imgArray[j];
            j += 1;
        }
    }

    //console.log(iData);
    useThisContext.putImageData(iData, 0, 0);
}

function showImageArrayDelta(imgArrayI1, imgArrayDelta) {
    const deltaCanvas = document.getElementById("deltacanvas");
    const deltaCtx = deltaCanvas.getContext("2d");

    showImageArray(deltaCtx, imgArrayDelta);

    const iData = offCtx.createImageData(
        deltaCanvas.width, deltaCanvas.height);
    // save the non-RGBA computed image too for next frame
    const computedImage = new Uint8ClampedArray(imgArrayI1.length);
    for (let i = 0, j = 0; j < imgArrayI1.length; ++i) {
        if ((i % 4) == 3) { // A
            iData.data[i] = 255;
        } else {    // R G B
            iData.data[i] = imgArrayI1[j] ^ imgArrayDelta[j];
            computedImage[j] = imgArrayI1[j] ^ imgArrayDelta[j];
            j += 1;
        }
    }

    //console.log(iData);
    ctx.putImageData(iData, 0, 0);

    return computedImage;
}

const videoImg = document.getElementById("videoimg");
function showScaledVideo() {
    const imgUrl = canvas.toDataURL();
    videoImg.src = imgUrl;
}


let i = 1;
function doTheVideo() {
    const videoTimer = setInterval(function () {
            fetch(`/imga/${i}`).then(x => x.json()).then(x => showImageArray(ctx, x));
            i += 1;
            if (i >= 900) {
                clearInterval(videoTimer);
            }
        }, 33);
}

function rle_decode(arr) {
    // [3 17 3 8...] --> [17 17 17 8 8 8...]
    const result = [];
    for (let i = 0 ; i < arr.length ; i = i + 2) {
        const repetition_count = arr[i];
        const symbol = arr[i+1];
        for (let j = 0 ; j < repetition_count ; ++j) {
            result.push(symbol);
        }
    }

    return result;
}

/* fetch(`/imga/123`).then(x => x.json()).then(function (i1) {
    showImageArray(ctx, rle_decode(i1));
    //fetch(`/imgad/900`).then(x => x.json()).then(i2d => showImageArrayDelta(i1, i2d));
}); */

// TODO: Move to a player object
let bufSource;
function playAudioArray(x) {
    const aCtx = new window.AudioContext();
    const buf = aCtx.createBuffer(1, x.length, 8000);
    const bufChan = buf.getChannelData(0);
    for (let i = 0; i < x.length; ++i) {
        bufChan[i] = (x[i] - 128) / 128.0;
    }

    bufSource = aCtx.createBufferSource();
    bufSource.buffer = buf;
    bufSource.connect(aCtx.destination);
    bufSource.start();
}

function doTheAudio() {
    fetch("/a").then(x => x.json()).then(function (x) {
        playAudioArray(x);
        doTheVideo();
    });
}

//doTheAudio();

function adjustVideoCanvases(width, height) {
    console.log("adjustVideoCanvases: " + width + ", " + height);
    const deltaCanvas = document.getElementById("deltacanvas");

    canvas.width = width;
    canvas.height = height;

    offcanvas.width = width;
    offcanvas.height = height;

    deltaCanvas.width = width;
    deltaCanvas.height = height;
}

function emitMetric(metricName, value) {
    console.log(metricName, value);
    const bundle = JSON.stringify({metricName: value});
    const stringified = encodeURIComponent(bundle);
    console.log(stringified);
    fetch("/metric?d=" + stringified).then(console.log("emitMetric: sent"));
}

// TODO: Move to a player object
let videoTimer;
let startTime;
function play(csgson) {
    console.log("Playing CSGSON:", csgson);
    // TODO: read more of the metadata
    const videoWidth = csgson["meta"]["resolution"]["width"];
    const videoHeight = csgson["meta"]["resolution"]["height"];
    adjustVideoCanvases(videoWidth, videoHeight);

    // TODO: check the audio / video sync, not async streams
    playAudioArray(csgson["audio"]);

    const firstImage = rle_decode(csgson["image"]);
    let lastDelta = firstImage;

    showImageArray(ctx, firstImage);
    const endTime = Date.now();
    const ttp = endTime - startTime;
    let i = 0;
    videoTimer = setInterval(function () {
            const nextDelta = rle_decode(csgson["deltas"][i]);
            lastDelta = showImageArrayDelta(lastDelta, nextDelta);
            showScaledVideo();
            //console.log(lastDelta);
            //lastDelta = nextDelta;

            i += 1;
            // TODO: check this is not off by one
            if (i >= csgson["deltas"].length) {
                clearInterval(videoTimer);
            }
        //}, 1000);
        }, 33);
    emitMetric("ttp", ttp);
}

function singleFrame(csgson) {
    const firstImage = rle_decode(csgson["image"]);
    //console.log(firstImage);
    showImageArray(ctx, firstImage);
}

function fetchAndPlay() {
    const cdnBaseUrl = "{{ data["cdnbaseurl"] }}/movie/";
    //const selectedMovieFile = "movie4-240p-0.csgson";
    //const selectedMovieFile = "movie5-240p-0.csgson";
    const selectedMovieFile = window.location.search.slice(1);
    const url = cdnBaseUrl + selectedMovieFile;
    //fetch(url).then(x => x.json()).then(singleFrame);
    startTime = Date.now();
    fetch(url).then(x => x.json()).then(play);
}

function stopPlaying() {
    console.log("stopping");
    if (typeof videoTimer !== "undefined") {
        clearInterval(videoTimer);
    }

    if (typeof bufSource !== "undefined") {
        bufSource.stop();
    }
}

function handleKey(evt) {
    console.log(evt);
    if (evt.key === "b") {
        fetchAndPlay();
    } else if (evt.key === "a") {
        window.history.back();
    } else if (evt.key === "x") {
        stopPlaying();
    }
}

window.addEventListener("keydown", handleKey);

</script>
<button onclick="fetchAndPlay()" autofocus>Play Button</button>
<button onclick="stopPlaying()">Stop Button</button>
</body>
</html>
